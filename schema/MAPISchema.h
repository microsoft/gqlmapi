// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#pragma once

#ifndef MAPISCHEMA_H
#define MAPISCHEMA_H

#include "graphqlservice/internal/Schema.h"

// Check if the library version is compatible with schemagen 4.5.0
static_assert(graphql::internal::MajorVersion == 4, "regenerate with schemagen: major version mismatch");
static_assert(graphql::internal::MinorVersion == 5, "regenerate with schemagen: minor version mismatch");

#include <array>
#include <memory>
#include <string>
#include <string_view>

namespace graphql {
namespace mapi {

enum class [[nodiscard]] SpecialFolder
{
	INBOX,
	CALENDAR,
	CONTACTS,
	TASKS,
	ARCHIVE,
	DELETED,
	DRAFTS,
	OUTBOX,
	SENT,
	SPAM
};

[[nodiscard]] constexpr auto getSpecialFolderNames() noexcept
{
	using namespace std::literals;

	return std::array<std::string_view, 10> {
		R"gql(INBOX)gql"sv,
		R"gql(CALENDAR)gql"sv,
		R"gql(CONTACTS)gql"sv,
		R"gql(TASKS)gql"sv,
		R"gql(ARCHIVE)gql"sv,
		R"gql(DELETED)gql"sv,
		R"gql(DRAFTS)gql"sv,
		R"gql(OUTBOX)gql"sv,
		R"gql(SENT)gql"sv,
		R"gql(SPAM)gql"sv
	};
}

[[nodiscard]] constexpr auto getSpecialFolderValues() noexcept
{
	using namespace std::literals;

	return std::array<std::pair<std::string_view, SpecialFolder>, 10> {
		std::make_pair(R"gql(SENT)gql"sv, SpecialFolder::SENT),
		std::make_pair(R"gql(SPAM)gql"sv, SpecialFolder::SPAM),
		std::make_pair(R"gql(INBOX)gql"sv, SpecialFolder::INBOX),
		std::make_pair(R"gql(TASKS)gql"sv, SpecialFolder::TASKS),
		std::make_pair(R"gql(DRAFTS)gql"sv, SpecialFolder::DRAFTS),
		std::make_pair(R"gql(OUTBOX)gql"sv, SpecialFolder::OUTBOX),
		std::make_pair(R"gql(ARCHIVE)gql"sv, SpecialFolder::ARCHIVE),
		std::make_pair(R"gql(DELETED)gql"sv, SpecialFolder::DELETED),
		std::make_pair(R"gql(CALENDAR)gql"sv, SpecialFolder::CALENDAR),
		std::make_pair(R"gql(CONTACTS)gql"sv, SpecialFolder::CONTACTS)
	};
}

enum class [[nodiscard]] PropType
{
	INT,
	BOOL,
	STRING,
	GUID,
	DATETIME,
	BINARY,
	STREAM
};

[[nodiscard]] constexpr auto getPropTypeNames() noexcept
{
	using namespace std::literals;

	return std::array<std::string_view, 7> {
		R"gql(INT)gql"sv,
		R"gql(BOOL)gql"sv,
		R"gql(STRING)gql"sv,
		R"gql(GUID)gql"sv,
		R"gql(DATETIME)gql"sv,
		R"gql(BINARY)gql"sv,
		R"gql(STREAM)gql"sv
	};
}

[[nodiscard]] constexpr auto getPropTypeValues() noexcept
{
	using namespace std::literals;

	return std::array<std::pair<std::string_view, PropType>, 7> {
		std::make_pair(R"gql(INT)gql"sv, PropType::INT),
		std::make_pair(R"gql(BOOL)gql"sv, PropType::BOOL),
		std::make_pair(R"gql(GUID)gql"sv, PropType::GUID),
		std::make_pair(R"gql(BINARY)gql"sv, PropType::BINARY),
		std::make_pair(R"gql(STREAM)gql"sv, PropType::STREAM),
		std::make_pair(R"gql(STRING)gql"sv, PropType::STRING),
		std::make_pair(R"gql(DATETIME)gql"sv, PropType::DATETIME)
	};
}

struct [[nodiscard]] ObjectId
{
	explicit ObjectId(
		response::IdType storeIdArg = response::IdType {},
		response::IdType objectIdArg = response::IdType {}) noexcept;
	ObjectId(const ObjectId& other);
	ObjectId(ObjectId&& other) noexcept;

	ObjectId& operator=(const ObjectId& other);
	ObjectId& operator=(ObjectId&& other) noexcept;

	response::IdType storeId {};
	response::IdType objectId {};
};

struct [[nodiscard]] NamedPropInput
{
	explicit NamedPropInput(
		response::Value propsetArg = response::Value {},
		std::optional<int> idArg = std::optional<int> {},
		std::optional<std::string> nameArg = std::optional<std::string> {}) noexcept;
	NamedPropInput(const NamedPropInput& other);
	NamedPropInput(NamedPropInput&& other) noexcept;

	NamedPropInput& operator=(const NamedPropInput& other);
	NamedPropInput& operator=(NamedPropInput&& other) noexcept;

	response::Value propset {};
	std::optional<int> id {};
	std::optional<std::string> name {};
};

struct [[nodiscard]] PropIdInput
{
	explicit PropIdInput(
		std::optional<int> idArg = std::optional<int> {},
		std::unique_ptr<NamedPropInput> namedArg = std::unique_ptr<NamedPropInput> {}) noexcept;
	PropIdInput(const PropIdInput& other);
	PropIdInput(PropIdInput&& other) noexcept;

	PropIdInput& operator=(const PropIdInput& other);
	PropIdInput& operator=(PropIdInput&& other) noexcept;

	std::optional<int> id {};
	std::unique_ptr<NamedPropInput> named {};
};

struct [[nodiscard]] PropValueInput
{
	explicit PropValueInput(
		std::optional<int> integerArg = std::optional<int> {},
		std::optional<bool> booleanArg = std::optional<bool> {},
		std::optional<std::string> stringArg = std::optional<std::string> {},
		std::optional<response::Value> guidArg = std::optional<response::Value> {},
		std::optional<response::Value> timeArg = std::optional<response::Value> {},
		std::optional<response::IdType> binArg = std::optional<response::IdType> {},
		std::optional<response::Value> streamArg = std::optional<response::Value> {}) noexcept;
	PropValueInput(const PropValueInput& other);
	PropValueInput(PropValueInput&& other) noexcept;

	PropValueInput& operator=(const PropValueInput& other);
	PropValueInput& operator=(PropValueInput&& other) noexcept;

	std::optional<int> integer {};
	std::optional<bool> boolean {};
	std::optional<std::string> string {};
	std::optional<response::Value> guid {};
	std::optional<response::Value> time {};
	std::optional<response::IdType> bin {};
	std::optional<response::Value> stream {};
};

struct PropertyInput;

struct [[nodiscard]] CreateItemInput
{
	explicit CreateItemInput(
		ObjectId folderIdArg = ObjectId {},
		std::string subjectArg = std::string {},
		std::optional<response::IdType> conversationIdArg = std::optional<response::IdType> {},
		bool readArg = bool {},
		std::optional<response::Value> receivedArg = std::optional<response::Value> {},
		std::optional<response::Value> modifiedArg = std::optional<response::Value> {},
		std::optional<std::vector<PropertyInput>> propertiesArg = std::optional<std::vector<PropertyInput>> {}) noexcept;
	CreateItemInput(const CreateItemInput& other);
	CreateItemInput(CreateItemInput&& other) noexcept;

	CreateItemInput& operator=(const CreateItemInput& other);
	CreateItemInput& operator=(CreateItemInput&& other) noexcept;

	ObjectId folderId {};
	std::string subject {};
	std::optional<response::IdType> conversationId {};
	bool read {};
	std::optional<response::Value> received {};
	std::optional<response::Value> modified {};
	std::optional<std::vector<PropertyInput>> properties {};
};

struct [[nodiscard]] CreateSubFolderInput
{
	explicit CreateSubFolderInput(
		ObjectId folderIdArg = ObjectId {},
		std::string nameArg = std::string {},
		std::optional<std::vector<PropertyInput>> propertiesArg = std::optional<std::vector<PropertyInput>> {}) noexcept;
	CreateSubFolderInput(const CreateSubFolderInput& other);
	CreateSubFolderInput(CreateSubFolderInput&& other) noexcept;

	CreateSubFolderInput& operator=(const CreateSubFolderInput& other);
	CreateSubFolderInput& operator=(CreateSubFolderInput&& other) noexcept;

	ObjectId folderId {};
	std::string name {};
	std::optional<std::vector<PropertyInput>> properties {};
};

struct [[nodiscard]] ModifyItemInput
{
	explicit ModifyItemInput(
		ObjectId idArg = ObjectId {},
		std::optional<std::string> subjectArg = std::optional<std::string> {},
		std::optional<bool> readArg = std::optional<bool> {},
		std::optional<std::vector<PropertyInput>> propertiesArg = std::optional<std::vector<PropertyInput>> {},
		std::optional<std::vector<PropIdInput>> deletedArg = std::optional<std::vector<PropIdInput>> {}) noexcept;
	ModifyItemInput(const ModifyItemInput& other);
	ModifyItemInput(ModifyItemInput&& other) noexcept;

	ModifyItemInput& operator=(const ModifyItemInput& other);
	ModifyItemInput& operator=(ModifyItemInput&& other) noexcept;

	ObjectId id {};
	std::optional<std::string> subject {};
	std::optional<bool> read {};
	std::optional<std::vector<PropertyInput>> properties {};
	std::optional<std::vector<PropIdInput>> deleted {};
};

struct [[nodiscard]] ModifyFolderInput
{
	explicit ModifyFolderInput(
		ObjectId folderIdArg = ObjectId {},
		std::optional<std::string> nameArg = std::optional<std::string> {},
		std::optional<std::vector<PropertyInput>> propertiesArg = std::optional<std::vector<PropertyInput>> {},
		std::optional<std::vector<PropIdInput>> deletedArg = std::optional<std::vector<PropIdInput>> {}) noexcept;
	ModifyFolderInput(const ModifyFolderInput& other);
	ModifyFolderInput(ModifyFolderInput&& other) noexcept;

	ModifyFolderInput& operator=(const ModifyFolderInput& other);
	ModifyFolderInput& operator=(ModifyFolderInput&& other) noexcept;

	ObjectId folderId {};
	std::optional<std::string> name {};
	std::optional<std::vector<PropertyInput>> properties {};
	std::optional<std::vector<PropIdInput>> deleted {};
};

struct [[nodiscard]] MultipleItemsInput
{
	explicit MultipleItemsInput(
		ObjectId folderIdArg = ObjectId {},
		std::vector<response::IdType> itemIdsArg = std::vector<response::IdType> {}) noexcept;
	MultipleItemsInput(const MultipleItemsInput& other);
	MultipleItemsInput(MultipleItemsInput&& other) noexcept;

	MultipleItemsInput& operator=(const MultipleItemsInput& other);
	MultipleItemsInput& operator=(MultipleItemsInput&& other) noexcept;

	ObjectId folderId {};
	std::vector<response::IdType> itemIds {};
};

struct [[nodiscard]] PropertyInput
{
	explicit PropertyInput(
		PropIdInput idArg = PropIdInput {},
		PropValueInput valueArg = PropValueInput {}) noexcept;
	PropertyInput(const PropertyInput& other);
	PropertyInput(PropertyInput&& other) noexcept;

	PropertyInput& operator=(const PropertyInput& other);
	PropertyInput& operator=(PropertyInput&& other) noexcept;

	PropIdInput id {};
	PropValueInput value {};
};

struct [[nodiscard]] Order
{
	explicit Order(
		bool descendingArg = bool {},
		PropIdInput propertyArg = PropIdInput {},
		PropType typeArg = PropType {}) noexcept;
	Order(const Order& other);
	Order(Order&& other) noexcept;

	Order& operator=(const Order& other);
	Order& operator=(Order&& other) noexcept;

	bool descending {};
	PropIdInput property {};
	PropType type {};
};

struct [[nodiscard]] Column
{
	explicit Column(
		PropIdInput propertyArg = PropIdInput {},
		PropType typeArg = PropType {}) noexcept;
	Column(const Column& other);
	Column(Column&& other) noexcept;

	Column& operator=(const Column& other);
	Column& operator=(Column&& other) noexcept;

	PropIdInput property {};
	PropType type {};
};

namespace object {

class Attachment;
class NamedPropId;
class PropId;
class PropValue;
class ItemChange;
class FolderChange;

class Query;
class Mutation;
class Subscription;
class Store;
class Folder;
class Item;
class FileAttachment;
class Conversation;
class IntId;
class StringId;
class NamedId;
class IntValue;
class BoolValue;
class StringValue;
class GuidValue;
class DateTimeValue;
class BinaryValue;
class StreamValue;
class Property;
class ItemAdded;
class ItemUpdated;
class ItemRemoved;
class ItemsReloaded;
class FolderAdded;
class FolderUpdated;
class FolderRemoved;
class FoldersReloaded;

} // namespace object

class [[nodiscard]] Operations final
	: public service::Request
{
public:
	explicit Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation, std::shared_ptr<object::Subscription> subscription);

	template <class TQuery, class TMutation, class TSubscription = service::SubscriptionPlaceholder>
	explicit Operations(std::shared_ptr<TQuery> query, std::shared_ptr<TMutation> mutation, std::shared_ptr<TSubscription> subscription = {})
		: Operations {
			std::make_shared<object::Query>(std::move(query)),
			std::make_shared<object::Mutation>(std::move(mutation)),
			subscription ? std::make_shared<object::Subscription>(std::move(subscription)) : std::shared_ptr<object::Subscription> {}
		}
	{
	}

private:
	std::shared_ptr<object::Query> _query;
	std::shared_ptr<object::Mutation> _mutation;
	std::shared_ptr<object::Subscription> _subscription;
};

void AddAttachmentDetails(const std::shared_ptr<schema::UnionType>& typeAttachment, const std::shared_ptr<schema::Schema>& schema);
void AddNamedPropIdDetails(const std::shared_ptr<schema::UnionType>& typeNamedPropId, const std::shared_ptr<schema::Schema>& schema);
void AddPropIdDetails(const std::shared_ptr<schema::UnionType>& typePropId, const std::shared_ptr<schema::Schema>& schema);
void AddPropValueDetails(const std::shared_ptr<schema::UnionType>& typePropValue, const std::shared_ptr<schema::Schema>& schema);
void AddItemChangeDetails(const std::shared_ptr<schema::UnionType>& typeItemChange, const std::shared_ptr<schema::Schema>& schema);
void AddFolderChangeDetails(const std::shared_ptr<schema::UnionType>& typeFolderChange, const std::shared_ptr<schema::Schema>& schema);

void AddQueryDetails(const std::shared_ptr<schema::ObjectType>& typeQuery, const std::shared_ptr<schema::Schema>& schema);
void AddMutationDetails(const std::shared_ptr<schema::ObjectType>& typeMutation, const std::shared_ptr<schema::Schema>& schema);
void AddSubscriptionDetails(const std::shared_ptr<schema::ObjectType>& typeSubscription, const std::shared_ptr<schema::Schema>& schema);
void AddStoreDetails(const std::shared_ptr<schema::ObjectType>& typeStore, const std::shared_ptr<schema::Schema>& schema);
void AddFolderDetails(const std::shared_ptr<schema::ObjectType>& typeFolder, const std::shared_ptr<schema::Schema>& schema);
void AddItemDetails(const std::shared_ptr<schema::ObjectType>& typeItem, const std::shared_ptr<schema::Schema>& schema);
void AddFileAttachmentDetails(const std::shared_ptr<schema::ObjectType>& typeFileAttachment, const std::shared_ptr<schema::Schema>& schema);
void AddConversationDetails(const std::shared_ptr<schema::ObjectType>& typeConversation, const std::shared_ptr<schema::Schema>& schema);
void AddIntIdDetails(const std::shared_ptr<schema::ObjectType>& typeIntId, const std::shared_ptr<schema::Schema>& schema);
void AddStringIdDetails(const std::shared_ptr<schema::ObjectType>& typeStringId, const std::shared_ptr<schema::Schema>& schema);
void AddNamedIdDetails(const std::shared_ptr<schema::ObjectType>& typeNamedId, const std::shared_ptr<schema::Schema>& schema);
void AddIntValueDetails(const std::shared_ptr<schema::ObjectType>& typeIntValue, const std::shared_ptr<schema::Schema>& schema);
void AddBoolValueDetails(const std::shared_ptr<schema::ObjectType>& typeBoolValue, const std::shared_ptr<schema::Schema>& schema);
void AddStringValueDetails(const std::shared_ptr<schema::ObjectType>& typeStringValue, const std::shared_ptr<schema::Schema>& schema);
void AddGuidValueDetails(const std::shared_ptr<schema::ObjectType>& typeGuidValue, const std::shared_ptr<schema::Schema>& schema);
void AddDateTimeValueDetails(const std::shared_ptr<schema::ObjectType>& typeDateTimeValue, const std::shared_ptr<schema::Schema>& schema);
void AddBinaryValueDetails(const std::shared_ptr<schema::ObjectType>& typeBinaryValue, const std::shared_ptr<schema::Schema>& schema);
void AddStreamValueDetails(const std::shared_ptr<schema::ObjectType>& typeStreamValue, const std::shared_ptr<schema::Schema>& schema);
void AddPropertyDetails(const std::shared_ptr<schema::ObjectType>& typeProperty, const std::shared_ptr<schema::Schema>& schema);
void AddItemAddedDetails(const std::shared_ptr<schema::ObjectType>& typeItemAdded, const std::shared_ptr<schema::Schema>& schema);
void AddItemUpdatedDetails(const std::shared_ptr<schema::ObjectType>& typeItemUpdated, const std::shared_ptr<schema::Schema>& schema);
void AddItemRemovedDetails(const std::shared_ptr<schema::ObjectType>& typeItemRemoved, const std::shared_ptr<schema::Schema>& schema);
void AddItemsReloadedDetails(const std::shared_ptr<schema::ObjectType>& typeItemsReloaded, const std::shared_ptr<schema::Schema>& schema);
void AddFolderAddedDetails(const std::shared_ptr<schema::ObjectType>& typeFolderAdded, const std::shared_ptr<schema::Schema>& schema);
void AddFolderUpdatedDetails(const std::shared_ptr<schema::ObjectType>& typeFolderUpdated, const std::shared_ptr<schema::Schema>& schema);
void AddFolderRemovedDetails(const std::shared_ptr<schema::ObjectType>& typeFolderRemoved, const std::shared_ptr<schema::Schema>& schema);
void AddFoldersReloadedDetails(const std::shared_ptr<schema::ObjectType>& typeFoldersReloaded, const std::shared_ptr<schema::Schema>& schema);

std::shared_ptr<schema::Schema> GetSchema();

} // namespace mapi
} // namespace graphql

#endif // MAPISCHEMA_H
